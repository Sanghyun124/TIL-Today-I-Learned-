def bfs(g, v, n):  # g: 그래프, v: 시작지점, n: 정점의 개수
    # 중복 탐색 방지를 위해 방문 배열 작성
    visited = [False] * (n + 1)
    # 정점번호가 1부터 시작하면 n+1
    # 0부터시작하면 n
    queue = []
    queue.append(v)  # 탐색을 시작할 초기 위치를 큐에 추가
    visited[v] = True

    # 반복을 계속 하는데
    # 초기에 탐색 시작 위치를 넣어주고 반복을 진행하기 때문에
    # 탐색위치가 남아있다면 큐가 비어있을 일이 없다.
    # 큐가 만약 비어있다면 탐색이 끝난것이다.
    while queue:
        t = queue.pop(0)#큐에서 맨 앞의 원소 가져오기
        print(f'{t}', end=' ')
        # 현재 위치인 t에서 갈 수 있는 정점들이 있는지 검사
        for i in g[t]: # 인접 리스트인 g(그래프)에서 t번 정점과 연결된 정점을 모두 탐색
            if not visited[i]:#다음 정점 i를 방문한 적이 없다면 탐색 대상이 되고, 탐색 대상은 큐에 추가
                # 큐에 추가한 후에 탐색했다 라는 표시를 하기위해서 방문 배열에 체크
                queue.append(i)
                visited[i]=True

g=[[],[2,3],[1,4,5],[1,7],[2,6],[2,6],[4,7],[3,6]]

bfs(g,1,7)

